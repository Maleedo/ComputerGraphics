<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ray Tracer: Ray Tracer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ray Tracer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classRay.html">Ray</a> Tracer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>We are using a couple of C++11 features, so please ensure that you use an up-to-date compiler (GCC 4.7 or higher, Visual Studio 2012). <a href="www.cmake.org">CMake</a> is used for setting up build environments.</p>
<h2>Building under Linux </h2>
<p>Inside the exercise's top-level directory, execute the following commands: </p><pre class="fragment">mkdir build
cd build
cmake ..
make
</pre><p>The last command &ndash; i.e. <code>make</code> &ndash; compiles the application. Rerun it whenever you have added/changed code in order to recompile.</p>
<h2>Building under MacOS </h2>
<p>Inside the exercise's top-level directory, execute the following commands: </p><pre class="fragment">mkdir xcode
cd xcode
cmake -G Xcode ..
open RayTracing.xcodeproj
</pre><h2>Running the <a class="el" href="classRay.html">Ray</a> Tracer unter MaxOS and Linux </h2>
<p>The program expects two command line arguments: an input scene (<code>*.sce</code>) and an output image (<code>*.png</code>). To render the scene with the three spheres, while inside the <code>build</code> directory, type: </p><pre class="fragment">./raytrace ../scenes/spheres/spheres.sce output.png
</pre><p>If you have finished all exercise tasks, use </p><pre class="fragment">./raytrace 0
</pre><p>to render all scenes at once.</p>
<p>To set the command line parameters in MSVC or Xcode, please refer to the documentation of these programs (or use the command line...).</p>
<h2>Build and Run under Microsoft Windows (Visual Studio) </h2>
<ul>
<li>Download and install <a href="https://www.visualstudio.com/vs/community/">Visual Studio Community</a></li>
<li>Make sure that you check "Desktop development with C++" during installation</li>
<li>Download <a href="https://cmake.org/download/">cmake</a> via the platform windows .zip version and extract it somewhere</li>
<li>Create an empty build folder inside the project's top-level directory</li>
<li>Start cmake-gui.exe (located in cmake's bin folder)</li>
<li>Specify the top-level directory as source directory (button Browse source...)</li>
<li>Specify the previously created build folder as build directory (button Browse build...)</li>
<li>Select Configure using your Visual Studio Version as option.</li>
<li>When configuration is finished, select Generate.</li>
<li>Start Visual Studio Community</li>
<li>Open the project via File -&gt; open -&gt; project -&gt; .sln in build folder</li>
<li>In the project explorer window on the right, right-click the project (raytracer) and set it as startup-project</li>
<li>Switch to release mode</li>
<li>The executable will need a scene file (.sce) and the output .png file as command line arguments (or 0 to raytrace all scenes). You can specify those arguments via project -&gt; properties -&gt; debugging -&gt; command arguments</li>
<li>Hit CTRL + F5 to build and run (or CTRL + SHIFT + B to build)</li>
</ul>
<h2>Dokumentation </h2>
<p>A pre-build html dokumentation can be found in <code>doc/index.html</code> and can be opened via any web browser.</p>
<h2>Code Overview </h2>
<p>The best way to become familiar with the code is to look at the main function in the file <code><a class="el" href="raytrace_8cpp.html">raytrace.cpp</a></code>. It consists of three parts: loading a scene, ray tracing it and write the resulting image. The function <code><a class="el" href="raytrace_8cpp.html#ab1d1ac9ba4ad1639618cfd7613fee95f" title="main function where the image is allocated and the raytracing is started ">compute_image()</a></code> is the starting point for the ray tracer.</p>
<h2>Recommended order for the exercises </h2>
<p>We recommend that you work on the tasks in the following order. All tasks can be found in the ToDo list as well.</p>
<p>Note that, to give you something to compare to, we provide output images created with a completed version of the exercise. They can be found inside the respective scene's directory, e.g. <code>scenes/spheres/</code>. Refer to the lecture's slides to get an idea of what the intermediate steps look like.</p>
<ul>
<li><b>Phong Shading and Reflections (3 points):</b> Begin by implementing the Phong shading model. Your starting point will be the <code><a class="el" href="raytrace_8cpp.html#a5e60c6656e2842b3fb847ce7d0ed3d1c" title="Computes the phong lighting. ">lighting()</a></code> function in <code><a class="el" href="raytrace_8cpp.html">raytrace.cpp</a></code>. Once you have finished the Phong Shading and get realistic illumination, continue with reflections, which have to be added to <code><a class="el" href="raytrace_8cpp.html#aed1edbb079a95ff44c4dbd3f4389c755" title="Finds the closest colision point for the passed Ray and returns the computed color for this object...">trace()</a></code> in <code><a class="el" href="raytrace_8cpp.html">raytrace.cpp</a></code>. During coding, ensure you are on the right track by ray tracing the spheres (<code>scenes/spheres/spheres.sce</code>).</li>
<li><b>Intersection computation with a plane (1 points):</b> To complete proper rendering of the spheres, implement ray-plane intersections (<code><a class="el" href="classPlane.html#ac008f08d6184f4acbcf5f74e4bfe67da">Plane::intersect()</a></code> in <code><a class="el" href="Plane_8cpp.html">Plane.cpp</a></code>).</li>
<li><b>Triangle Meshes (4 points):</b> <a class="el" href="classRay.html">Ray</a> tracing spheres is great (try the scenes with molecules!), but because we want to be able to render more complex scenes, we cannot stop there. The next step is the ray-triangle intersection (<code><a class="el" href="classMesh.html#aa74d8ad552ae505e9178a9fc8a0e75d7">Mesh::intersect_triangle()</a></code> in <code><a class="el" href="Mesh_8cpp.html">Mesh.cpp</a></code>). Start testing with the cube (<code>scenes\cube\cube.sce</code>), which uses flat shading. Then try the office (<code>scenes\office\office.sce</code>) or the toon faces (<code>scenes\toon_faces\toon_faces.sce</code>). For those scenes, computation of vertex normals needs to be implemented (<code><a class="el" href="classMesh.html#a4e9bedfc415b7135c9587f63535fcb6d" title="Compute normal vectors for triangles and vertices. ">Mesh::compute_normals</a></code> in <code><a class="el" href="Mesh_8cpp.html">Mesh.cpp</a></code>). Implement weighted vertex normals to get a nice result in the rings scene (<code>scenes\rings\rings.sce</code>).</li>
<li><b>Acceleration (1 point):</b> Are you annoyed because raytracing is damn slow? Let's make things faster! First implement the bounding box test for triangle meshes (<code><a class="el" href="classMesh.html#a3080b2a18bc22092dd704c0fc1970c7d" title="Does _ray intersect the bounding box of the mesh? ">Mesh::intersect_bounding_box()</a></code> in <code><a class="el" href="Mesh_8cpp.html">Mesh.cpp</a></code>). With this feature you should see a significant performance boost rendering the toon faces (<code>scenes\toon_faces\toon_faces.sce</code>). Also try using OpenMP to enable parallelization. For this, simply put (<code>#pragma omp parallel for</code>) above the outer loop in during ray generation (<code><a class="el" href="raytrace_8cpp.html#ab1d1ac9ba4ad1639618cfd7613fee95f" title="main function where the image is allocated and the raytracing is started ">compute_image()</a></code> in <code><a class="el" href="raytrace_8cpp.html">raytrace.cpp</a></code>).</li>
<li><b>Textures (1 point)</b> One color per object is boring. Complete the texture support in <code><a class="el" href="classMesh.html#aa74d8ad552ae505e9178a9fc8a0e75d7">Mesh::intersect_triangle()</a></code> and render our cool new Pokemon scene (<code>scenes\pokemon\pokemon.sce</code>).</li>
<li><b>Render all scenes:</b> If you finished all the tasks above, you can render all scenes (command line argument 0). Compare your results to those in the scenes folder. You should get the same pictures, if you did no mistakes.</li>
<li><b>Bonus Task (1 bonus point):</b> Do you still want to explore more features? Then why not try super-sampling in order to reduce the aliasing problems? Simply adjust the function <code><a class="el" href="raytrace_8cpp.html#ab1d1ac9ba4ad1639618cfd7613fee95f" title="main function where the image is allocated and the raytracing is started ">compute_image()</a></code>, such that you shoot several rays for each pixel and average their resulting colors. To avoid loosing too much performance, you should implement adaptive supersampling (details in <code><a class="el" href="raytrace_8cpp.html#ab1d1ac9ba4ad1639618cfd7613fee95f" title="main function where the image is allocated and the raytracing is started ">compute_image()</a></code>). There are also 16-ray-supersampled versions of the images in each scene folder for comparison (suffix _SS16). </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
